//! GFF output functionality for Augustus hints

use crate::types::{AnnoRefineError, AugustusHint, HintType, Result};
use log::debug;
use std::io::Write;

/// Writer for Augustus hints in GFF format
pub struct HintsWriter<W: Write> {
    writer: W,
    pub hints_written: usize,
    contig_map: std::collections::HashMap<String, String>,
}

impl<W: Write> HintsWriter<W> {
    /// Create a new hints writer
    pub fn new(writer: W) -> Self {
        Self {
            writer,
            hints_written: 0,
            contig_map: std::collections::HashMap::new(),
        }
    }

    /// Create a new hints writer with contig name mapping
    pub fn new_with_contig_map(
        writer: W,
        contig_map: std::collections::HashMap<String, String>,
    ) -> Self {
        Self {
            writer,
            hints_written: 0,
            contig_map,
        }
    }

    /// Write a header comment to the GFF file
    pub fn write_header(&mut self, input_file: &str, config_summary: &str) -> Result<()> {
        writeln!(
            self.writer,
            "# gene model hints generated by annorefine bam2hints"
        )?;
        writeln!(self.writer, "# Input BAM file: {}", input_file)?;
        writeln!(self.writer, "# Configuration: {}", config_summary)?;
        writeln!(
            self.writer,
            "# Format: seqname\tsource\tfeature\tstart\tend\tscore\tstrand\tframe\tattributes"
        )?;
        Ok(())
    }

    /// Write a single hint to the GFF file
    pub fn write_hint(&mut self, hint: &AugustusHint) -> Result<()> {
        // Apply contig mapping if present
        let output_contig = self
            .contig_map
            .get(&hint.chromosome)
            .unwrap_or(&hint.chromosome);

        // Build GFF line with potentially mapped contig name
        let mut attributes = Vec::new();
        if hint.multiplicity > 1 {
            attributes.push(format!("mult={}", hint.multiplicity));
        }
        attributes.push(format!("pri={}", hint.priority));
        attributes.push(format!("src={}", hint.source));
        let attributes_str = attributes.join(";");

        let gff_line = format!(
            "{}\tb2h\t{}\t{}\t{}\t{}\t{}\t.\t{}",
            output_contig,
            hint.hint_type,
            hint.start,
            hint.end,
            hint.score,
            hint.strand,
            attributes_str
        );

        writeln!(self.writer, "{}", gff_line)?;
        self.hints_written += 1;
        Ok(())
    }

    /// Write multiple hints to the GFF file
    pub fn write_hints(&mut self, hints: &[AugustusHint]) -> Result<()> {
        for hint in hints {
            self.write_hint(hint)?;
        }
        Ok(())
    }

    /// Write hints grouped by type with sorting
    pub fn write_hints_sorted(&mut self, mut hints: Vec<AugustusHint>) -> Result<()> {
        // Sort hints by chromosome, then by position, then by type
        hints.sort_by(|a, b| {
            a.chromosome
                .cmp(&b.chromosome)
                .then(a.start.cmp(&b.start))
                .then(a.end.cmp(&b.end))
                .then(a.hint_type.to_string().cmp(&b.hint_type.to_string()))
        });

        self.write_sorted_hints(hints)
    }

    /// Write hints sorted by BAM header chromosome order for deterministic output
    pub fn write_hints_sorted_by_chromosome_order(
        &mut self,
        mut hints: Vec<AugustusHint>,
        chromosome_order: &[String],
    ) -> Result<()> {
        // Create chromosome order map for efficient lookup
        let chr_order_map: std::collections::HashMap<String, usize> = chromosome_order
            .iter()
            .enumerate()
            .map(|(i, chr)| (chr.clone(), i))
            .collect();

        // Sort hints by BAM header chromosome order, then by position, then by type
        hints.sort_by(|a, b| {
            let a_chr_idx = chr_order_map.get(&a.chromosome).unwrap_or(&usize::MAX);
            let b_chr_idx = chr_order_map.get(&b.chromosome).unwrap_or(&usize::MAX);

            a_chr_idx
                .cmp(b_chr_idx)
                .then(a.start.cmp(&b.start))
                .then(a.end.cmp(&b.end))
                .then(a.hint_type.to_string().cmp(&b.hint_type.to_string()))
        });

        self.write_sorted_hints(hints)
    }

    /// Internal method to write already sorted hints with type grouping
    fn write_sorted_hints(&mut self, hints: Vec<AugustusHint>) -> Result<()> {
        // Write all hints without grouping comments
        for hint in &hints {
            self.write_hint(hint)?;
        }

        debug!("Wrote {} hints to GFF file", hints.len());
        Ok(())
    }

    /// Write hints with coverage filtering
    pub fn write_hints_with_coverage_filter(
        &mut self,
        hints: Vec<AugustusHint>,
        max_coverage: u32,
    ) -> Result<()> {
        if max_coverage == 0 {
            // No filtering
            return self.write_hints_sorted(hints);
        }

        // Apply coverage filtering
        let filtered_hints = self.apply_coverage_filter(hints, max_coverage)?;
        self.write_hints_sorted(filtered_hints)
    }

    /// Write hints with coverage filtering using BAM header chromosome order
    pub fn write_hints_with_coverage_filter_ordered(
        &mut self,
        hints: Vec<AugustusHint>,
        max_coverage: u32,
        chromosome_order: &[String],
    ) -> Result<()> {
        if max_coverage == 0 {
            // No filtering
            return self.write_hints_sorted_by_chromosome_order(hints, chromosome_order);
        }

        // Apply coverage filtering
        let filtered_hints = self.apply_coverage_filter(hints, max_coverage)?;
        self.write_hints_sorted_by_chromosome_order(filtered_hints, chromosome_order)
    }

    /// Apply coverage filtering to limit hints in high-coverage regions
    fn apply_coverage_filter(
        &self,
        hints: Vec<AugustusHint>,
        max_coverage: u32,
    ) -> Result<Vec<AugustusHint>> {
        // Group hints by chromosome and position for coverage calculation
        use std::collections::HashMap;

        let mut position_counts: HashMap<(String, u64), u32> = HashMap::new();

        // Count hints at each position
        for hint in &hints {
            for pos in hint.start..=hint.end {
                let key = (hint.chromosome.clone(), pos);
                *position_counts.entry(key).or_insert(0) += 1;
            }
        }

        // Filter hints that would exceed coverage threshold
        let mut filtered = Vec::new();
        let mut current_coverage: HashMap<(String, u64), u32> = HashMap::new();

        let hints_len = hints.len();
        for hint in hints {
            // Check if adding this hint would exceed coverage at any position
            let mut would_exceed = false;
            for pos in hint.start..=hint.end {
                let key = (hint.chromosome.clone(), pos);
                let current = current_coverage.get(&key).unwrap_or(&0);
                if current >= &max_coverage {
                    would_exceed = true;
                    break;
                }
            }

            if !would_exceed {
                // Add this hint and update coverage
                for pos in hint.start..=hint.end {
                    let key = (hint.chromosome.clone(), pos);
                    *current_coverage.entry(key).or_insert(0) += 1;
                }
                filtered.push(hint);
            }
        }

        debug!(
            "Coverage filtering: {} -> {} hints",
            hints_len,
            filtered.len()
        );
        Ok(filtered)
    }

    /// Get the number of hints written
    pub fn hints_written(&self) -> usize {
        self.hints_written
    }

    /// Flush the writer
    pub fn flush(&mut self) -> Result<()> {
        self.writer.flush().map_err(|e| AnnoRefineError::Io(e))?;
        Ok(())
    }
}

/// Statistics about hints generation
#[derive(Debug, Default)]
pub struct HintsStatistics {
    pub total_alignments_processed: u64,
    pub alignments_with_hints: u64,
    pub intron_hints: u64,
    pub exon_hints: u64,
    pub exonpart_hints: u64,
    pub splice_site_hints: u64,
    pub total_hints: u64,
    pub chromosomes_processed: u32,
}

impl HintsStatistics {
    /// Create new statistics
    pub fn new() -> Self {
        Self::default()
    }

    /// Add hints from a batch
    pub fn add_hints(&mut self, hints: &[AugustusHint]) {
        for hint in hints {
            match hint.hint_type {
                HintType::Intron => self.intron_hints += 1,
                HintType::Exon => self.exon_hints += 1,
                HintType::Exonpart => self.exonpart_hints += 1,
                HintType::DSS | HintType::ASS => self.splice_site_hints += 1,
            }
        }
        self.total_hints += hints.len() as u64;
    }

    /// Record processed alignment
    pub fn add_alignment(&mut self, generated_hints: bool) {
        self.total_alignments_processed += 1;
        if generated_hints {
            self.alignments_with_hints += 1;
        }
    }

    /// Record processed chromosome
    pub fn add_chromosome(&mut self) {
        self.chromosomes_processed += 1;
    }

    /// Get summary string
    pub fn summary(&self) -> String {
        format!(
            "Processed {} alignments ({} with hints) from {} chromosomes. \
             Generated {} total hints: {} intron, {} exon, {} exonpart, {} splice sites",
            self.total_alignments_processed,
            self.alignments_with_hints,
            self.chromosomes_processed,
            self.total_hints,
            self.intron_hints,
            self.exon_hints,
            self.exonpart_hints,
            self.splice_site_hints
        )
    }
}

/// Utility functions for hint processing
pub mod utils {
    use super::*;

    /// Remove redundant hints (hints that are completely contained within others)
    pub fn remove_redundant_hints(hints: Vec<AugustusHint>) -> Vec<AugustusHint> {
        let mut filtered: Vec<AugustusHint> = Vec::new();
        let hints_len = hints.len();

        // Sort by start position for efficient comparison
        let mut sorted_hints = hints;
        sorted_hints.sort_by_key(|h| (h.chromosome.clone(), h.start, h.end));

        for hint in sorted_hints {
            let mut is_redundant = false;

            // Check if this hint is contained within any existing hint
            for existing in &filtered {
                if existing.chromosome == hint.chromosome
                    && existing.hint_type == hint.hint_type
                    && existing.strand == hint.strand
                    && existing.start <= hint.start
                    && existing.end >= hint.end
                {
                    is_redundant = true;
                    break;
                }
            }

            if !is_redundant {
                // Remove any existing hints that are contained within this hint
                filtered.retain(|existing| {
                    !(existing.chromosome == hint.chromosome
                        && existing.hint_type == hint.hint_type
                        && existing.strand == hint.strand
                        && hint.start <= existing.start
                        && hint.end >= existing.end)
                });

                filtered.push(hint);
            }
        }

        debug!(
            "Redundancy removal: {} -> {} hints",
            hints_len,
            filtered.len()
        );
        filtered
    }

    /// Merge overlapping hints of the same type
    pub fn merge_overlapping_hints(hints: Vec<AugustusHint>) -> Vec<AugustusHint> {
        let mut merged = Vec::new();

        // Group by chromosome, type, and strand
        use std::collections::HashMap;
        let mut groups: HashMap<(String, HintType, crate::types::Strand), Vec<AugustusHint>> =
            HashMap::new();

        let hints_len = hints.len();
        for hint in hints {
            let key = (hint.chromosome.clone(), hint.hint_type, hint.strand);
            groups.entry(key).or_insert_with(Vec::new).push(hint);
        }

        for (_, mut group_hints) in groups {
            // Sort by start position
            group_hints.sort_by_key(|h| h.start);

            let mut current_hint = group_hints[0].clone();

            for hint in group_hints.into_iter().skip(1) {
                if hint.start <= current_hint.end + 1 {
                    // Overlapping or adjacent - merge
                    current_hint.end = current_hint.end.max(hint.end);
                    current_hint.multiplicity += hint.multiplicity;
                } else {
                    // Non-overlapping - save current and start new
                    merged.push(current_hint);
                    current_hint = hint;
                }
            }

            merged.push(current_hint);
        }

        debug!("Overlap merging: {} -> {} hints", hints_len, merged.len());
        merged
    }
}
